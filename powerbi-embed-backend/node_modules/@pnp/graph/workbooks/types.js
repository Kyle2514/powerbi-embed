import { __decorate } from "tslib";
import { updateable, addable, getById, deleteable, defaultPath } from "../decorators.js";
import { _GraphCollection, graphInvokableFactory, _GraphInstance, GraphQueryable } from "../graphqueryable.js";
import { graphPost } from "@pnp/graph";
import { body, JSONParse } from "@pnp/queryable/index.js";
let _Workbook = class _Workbook extends _GraphInstance {
    get worksheets() {
        return Worksheets(this);
    }
    get tables() {
        return Tables(this);
    }
    get comments() {
        return Comments(this);
    }
    get names() {
        return NamedItems(this);
    }
    get operations() {
        return Operations(this);
    }
    get application() {
        return Application(this);
    }
};
_Workbook = __decorate([
    defaultPath("workbook")
], _Workbook);
export { _Workbook };
export const Workbook = graphInvokableFactory(_Workbook);
export class _WorkbookWithSession extends _Workbook {
    closeSession() {
        return graphPost(GraphQueryable(this, "closeSession"));
    }
    refreshSession() {
        return graphPost(GraphQueryable(this, "refreshSession"));
    }
}
export const WorkbookWithSession = graphInvokableFactory(_WorkbookWithSession);
let _Range = class _Range extends _GraphInstance {
    get format() {
        return RangeFormat(this);
    }
    get sort() {
        return RangeSort(this);
    }
    cell(row, column) {
        return Range(this, `cell(row=${row},column=${column})`);
    }
    column(column) {
        return Range(this, `column(column=${column})`);
    }
    columnsAfter(count = 1) {
        return Range(this, `columnsAfter(count=${count})`);
    }
    columnsBefore(count = 1) {
        return Range(this, `columnsBefore(count=${count})`);
    }
    row(row) {
        return Range(this, `row(row=${row})`);
    }
    rowsAbove(count = 1) {
        return Range(this, `rowsAbove(count=${count})`);
    }
    rowsBelow(count = 1) {
        return Range(this, `rowsBelow(count=${count})`);
    }
    get entireColumn() {
        return Range(this, "entireColumn");
    }
    get entireRow() {
        return Range(this, "entireRow");
    }
    // NOTE: A few methods here are documented incorrectly.
    // They're GET methods, but specify that their arguments
    // are supposed to be passed in the request body.
    // The API actually wants them in the query string, so
    // that's what we do here.
    intersection(anotherRange) {
        return Range(this, `intersection(anotherRange='${anotherRange}')`);
    }
    boundingRect(anotherRange) {
        return Range(this, `boundingRect(anotherRange='${anotherRange}')`);
    }
    get lastCell() {
        return Range(this, "lastCell");
    }
    get lastColumn() {
        return Range(this, "lastColumn");
    }
    get lastRow() {
        return Range(this, "lastRow");
    }
    offsetRange(rowOffset, columnOffset) {
        return Range(this, `offsetRange(rowOffset=${rowOffset}, columnOffset=${columnOffset})`);
    }
    // NOTE: Docs say this is a POST. It's a GET.
    resizedRange(deltaRows, deltaColumns) {
        return Range(this, `resizedRange(deltaRows=${deltaRows}, deltaColumns=${deltaColumns})`);
    }
    usedRange(valuesOnly) {
        return Range(this, `usedRange(valuesOnly=${valuesOnly})`);
    }
    get visibleView() {
        return RangeView(this, "visibleView");
    }
    insert(shift) {
        return graphPost(GraphQueryable(this, "insert"), body({ shift }));
    }
    merge(across) {
        return graphPost(GraphQueryable(this, "merge"), body({ across }));
    }
    unmerge() {
        return graphPost(GraphQueryable(this, "unmerge"));
    }
    clear(applyTo) {
        return graphPost(GraphQueryable(this, "clear"), body({ applyTo }));
    }
    delete(shift) {
        return graphPost(GraphQueryable(this, "delete"), body({ shift }));
    }
};
_Range = __decorate([
    updateable()
], _Range);
export { _Range };
export const Range = graphInvokableFactory(_Range);
export class _RangeView extends _GraphInstance {
    get rows() {
        return RangeViews(this, "rows");
    }
    get range() {
        return Range(this, "range");
    }
}
const RangeView = graphInvokableFactory(_RangeView);
let _RangeViews = class _RangeViews extends _GraphCollection {
};
_RangeViews = __decorate([
    getItemAt(RangeView)
], _RangeViews);
export { _RangeViews };
const RangeViews = graphInvokableFactory(_RangeViews);
let _RangeSort = class _RangeSort extends _GraphInstance {
    apply(params) {
        return graphPost(GraphQueryable(this, "apply"), body(params));
    }
};
_RangeSort = __decorate([
    defaultPath("sort")
], _RangeSort);
export { _RangeSort };
const RangeSort = graphInvokableFactory(_RangeSort);
let _RangeFormat = class _RangeFormat extends _GraphInstance {
    get borders() {
        return RangeBorders(this);
    }
    get font() {
        return RangeFont(this);
    }
    get fill() {
        return RangeFill(this);
    }
    get protection() {
        return RangeFormatProtection(this);
    }
    autofitColumns() {
        return graphPost(GraphQueryable(this, "autofitColumns"));
    }
    autofitRows() {
        return graphPost(GraphQueryable(this, "autofitRows"));
    }
};
_RangeFormat = __decorate([
    updateable(),
    defaultPath("format")
], _RangeFormat);
export { _RangeFormat };
export const RangeFormat = graphInvokableFactory(_RangeFormat);
let _RangeFont = class _RangeFont extends _GraphInstance {
};
_RangeFont = __decorate([
    defaultPath("font"),
    updateable()
], _RangeFont);
export { _RangeFont };
export const RangeFont = graphInvokableFactory(_RangeFont);
let _RangeFill = class _RangeFill extends _GraphInstance {
    clear() {
        return graphPost(GraphQueryable(this, "clear"));
    }
};
_RangeFill = __decorate([
    defaultPath("fill"),
    updateable()
], _RangeFill);
export { _RangeFill };
export const RangeFill = graphInvokableFactory(_RangeFill);
let _RangeFormatProtection = class _RangeFormatProtection extends _GraphInstance {
};
_RangeFormatProtection = __decorate([
    defaultPath("protection"),
    updateable()
], _RangeFormatProtection);
export { _RangeFormatProtection };
export const RangeFormatProtection = graphInvokableFactory(_RangeFormatProtection);
let _RangeBorder = class _RangeBorder extends _GraphInstance {
};
_RangeBorder = __decorate([
    updateable()
], _RangeBorder);
export { _RangeBorder };
export const RangeBorder = graphInvokableFactory(_RangeBorder);
let _RangeBorders = class _RangeBorders extends _GraphCollection {
    getBySideIndex(sideIndex) {
        return RangeBorder(this, sideIndex);
    }
};
_RangeBorders = __decorate([
    defaultPath("borders")
    // @addable()
    /**
     * NOTE: According the docs at https://learn.microsoft.com/en-us/graph/api/rangeformat-post-borders,
     * you should be able to POST new border styles. In my testing, this fails with MethodNotAllowed
     * Using `RangeBorder.update()` works instead, even for borders that haven't been "created" yet.
     */
    ,
    getItemAt(RangeBorder)
], _RangeBorders);
export { _RangeBorders };
export const RangeBorders = graphInvokableFactory(_RangeBorders);
let _Worksheet = class _Worksheet extends _GraphInstance {
    /**
     * Get a range of cells within the worksheet.
     *
     * @param address (Optional) An A1-notation address of a range within this worksheet.
     * If omitted, a range containing the entire worksheet is returned.
     */
    getRange(address) {
        if (address) {
            return Range(this, `range(address='${address}')`);
        }
        else {
            return Range(this, "range");
        }
    }
    getUsedRange(valuesOnly) {
        if (valuesOnly) {
            return Range(this, `usedRange(valuesOnly=${valuesOnly})`);
        }
        else {
            return Range(this, "usedRange");
        }
    }
    get tables() {
        return Tables(this);
    }
    get pivotTables() {
        return PivotTables(this, "pivotTables");
    }
    get names() {
        return NamedItems(this, "names");
    }
    get protection() {
        return WorksheetProtection(this, "protection");
    }
};
_Worksheet = __decorate([
    updateable(),
    deleteable()
], _Worksheet);
export { _Worksheet };
export const Worksheet = graphInvokableFactory(_Worksheet);
let _Worksheets = class _Worksheets extends _GraphCollection {
};
_Worksheets = __decorate([
    defaultPath("worksheets"),
    addable(),
    getById(Worksheet)
], _Worksheets);
export { _Worksheets };
export const Worksheets = graphInvokableFactory(_Worksheets);
export class _WorksheetProtection extends _GraphInstance {
    protect(options) {
        return graphPost(GraphQueryable(this, "protect"), body(options));
    }
    unprotect() {
        return graphPost(GraphQueryable(this, "unprotect"));
    }
}
export const WorksheetProtection = graphInvokableFactory(_WorksheetProtection);
let _Table = class _Table extends _GraphInstance {
    get rows() {
        return TableRows(this);
    }
    get columns() {
        return TableColumns(this);
    }
    get worksheet() {
        return Worksheet(this, "worksheet");
    }
    get range() {
        return Range(this, "range");
    }
    get headerRowRange() {
        return Range(this, "headerRowRange");
    }
    get dataBodyRange() {
        return Range(this, "dataBodyRange");
    }
    get totalRowRange() {
        return Range(this, "totalRowRange");
    }
    get sort() {
        return TableSort(this);
    }
    clearFilters() {
        return graphPost(GraphQueryable(this, "clearFilters"));
    }
    reapplyFilters() {
        return graphPost(GraphQueryable(this, "reapplyFilters"));
    }
    convertToRange() {
        return graphPost(GraphQueryable(this, "convertToRange"));
    }
};
_Table = __decorate([
    getRange(),
    updateable(),
    deleteable()
], _Table);
export { _Table };
export const Table = graphInvokableFactory(_Table);
let _Tables = class _Tables extends _GraphCollection {
    getByName(name) {
        return Table(this, name);
    }
    async add(address, hasHeaders) {
        return graphPost(GraphQueryable(this, "add"), body({ address, hasHeaders }));
    }
};
_Tables = __decorate([
    defaultPath("tables"),
    getById(Table)
], _Tables);
export { _Tables };
export const Tables = graphInvokableFactory(_Tables);
let _TableRow = class _TableRow extends _GraphInstance {
};
_TableRow = __decorate([
    getRange(),
    deleteable(),
    updateable()
], _TableRow);
export { _TableRow };
export const TableRow = graphInvokableFactory(_TableRow);
let _TableRows = class _TableRows extends _GraphCollection {
};
_TableRows = __decorate([
    defaultPath("rows"),
    addable(),
    getItemAt(TableRow)
], _TableRows);
export { _TableRows };
export const TableRows = graphInvokableFactory(_TableRows);
let _TableColumn = class _TableColumn extends _GraphInstance {
    get filter() {
        return WorkbookFilter(this);
    }
    get headerRowRange() {
        return Range(this, "headerRowRange");
    }
    get dataBodyRange() {
        return Range(this, "dataBodyRange");
    }
    get totalRowRange() {
        return Range(this, "totalRowRange");
    }
};
_TableColumn = __decorate([
    getRange(),
    deleteable(),
    updateable()
], _TableColumn);
export { _TableColumn };
export const TableColumn = graphInvokableFactory(_TableColumn);
let _TableColumns = class _TableColumns extends _GraphCollection {
    getByName(name) {
        return TableColumn(this, name);
    }
};
_TableColumns = __decorate([
    defaultPath("columns"),
    addable(),
    getItemAt(TableColumn)
], _TableColumns);
export { _TableColumns };
export const TableColumns = graphInvokableFactory(_TableColumns);
let _WorkbookFilter = class _WorkbookFilter extends _GraphInstance {
    apply(filter) {
        /**
         * NOTE: The "criterion" object you pass here MUST have a
         * "filterOn" property, otherwise you get a 500.
         * The docs aren't clear on what you need to set this to.
         * Excel seems to set it to "Custom", which works in my testing.
         * We could do this for users here, though there could be
         * scenarios in which you might want it to be something else.
         */
        return graphPost(GraphQueryable(this, "apply"), body(filter));
    }
    clear() {
        return graphPost(GraphQueryable(this, "clear"));
    }
};
_WorkbookFilter = __decorate([
    defaultPath("filter")
], _WorkbookFilter);
export { _WorkbookFilter };
export const WorkbookFilter = graphInvokableFactory(_WorkbookFilter);
let _TableSort = class _TableSort extends _GraphInstance {
    apply(fields, matchCase, method) {
        return graphPost(GraphQueryable(this, "apply"), body({ fields, matchCase, method }));
    }
    clear() {
        return graphPost(GraphQueryable(this, "clear"));
    }
    reapply() {
        return graphPost(GraphQueryable(this, "reapply"));
    }
};
_TableSort = __decorate([
    defaultPath("sort")
], _TableSort);
export { _TableSort };
export class ITableSort extends _TableSort {
}
export const TableSort = graphInvokableFactory(_TableSort);
// See above
// export class _SortFields extends _GraphInstance<WorkbookSortFieldType[]> {
//     public get icon(): IIcon {
//         return Icon(this, "icon");
//     }
// }
// export interface ISortFields extends _SortFields {}
// export const SortFields = graphInvokableFactory<ISortFields>(_SortFields);
export class _PivotTable extends _GraphInstance {
    refresh() {
        return graphPost(GraphQueryable(this, "refresh"));
    }
}
export const PivotTable = graphInvokableFactory(_PivotTable);
let _PivotTables = class _PivotTables extends _GraphCollection {
    refreshAll() {
        return graphPost(GraphQueryable(this, "refreshAll"));
    }
};
_PivotTables = __decorate([
    getById(PivotTable)
], _PivotTables);
export { _PivotTables };
export const PivotTables = graphInvokableFactory(_PivotTables);
let _NamedItem = class _NamedItem extends _GraphInstance {
    get range() {
        return Range(this, "range");
    }
};
_NamedItem = __decorate([
    updateable()
], _NamedItem);
export { _NamedItem };
export const NamedItem = graphInvokableFactory(_NamedItem);
let _NamedItems = class _NamedItems extends _GraphCollection {
    /**
     * The NamedItem object contains string property named "value".
     * This causes an issue with the DefaultParse
     * parser (namely parseODataJSON), because it's set up to throw away
     * the rest of the object if it contains a field "value".
     *
     * Below I'm manually replacing the parser with JSONParse. This works,
     * but is unideal because it would replace any custom parser a user
     * may have set up earlier.
     *
     * I know the docs caution against making changes in the
     * core classes - my suggestion would be to change
     * the check in parseODataJSON from `hasOwnProperty` to something like
     * `typeof json["value"] === "object"`. Thoughts?
     */
    add(item) {
        const q = GraphQueryable(this, "add");
        q.using(JSONParse());
        return graphPost(q, body(item));
    }
    getByName(name) {
        const q = NamedItem(this, name);
        q.using(JSONParse());
        return q;
    }
};
_NamedItems = __decorate([
    defaultPath("names")
    // @getById(NamedItem)
], _NamedItems);
export { _NamedItems };
export const NamedItems = graphInvokableFactory(_NamedItems);
export class _Comment extends _GraphInstance {
    get replies() {
        return CommentReplies(this);
    }
}
export const Comment = graphInvokableFactory(_Comment);
let _Comments = class _Comments extends _GraphCollection {
};
_Comments = __decorate([
    getById(Comment),
    defaultPath("comments")
], _Comments);
export { _Comments };
export const Comments = graphInvokableFactory(_Comments);
export class _CommentReply extends _GraphInstance {
}
export const CommentReply = graphInvokableFactory(_CommentReply);
let _CommentReplies = class _CommentReplies extends _GraphInstance {
};
_CommentReplies = __decorate([
    defaultPath("replies"),
    getById(CommentReply),
    addable()
], _CommentReplies);
export { _CommentReplies };
export const CommentReplies = graphInvokableFactory(_CommentReplies);
let _Application = class _Application extends _GraphInstance {
    calculate(calculationType) {
        return graphPost(GraphQueryable(this, "calculate"), body({ calculationType }));
    }
};
_Application = __decorate([
    defaultPath("application")
], _Application);
export { _Application };
export const Application = graphInvokableFactory(_Application);
export class _Operation extends _GraphInstance {
}
export const Operation = graphInvokableFactory(_Operation);
let _Operations = class _Operations extends _GraphCollection {
};
_Operations = __decorate([
    defaultPath("operations"),
    getById(Operation)
], _Operations);
export { _Operations };
export const Operations = graphInvokableFactory(_Operations);
let _Icon = class _Icon extends _GraphInstance {
};
_Icon = __decorate([
    updateable()
], _Icon);
export { _Icon };
export const Icon = graphInvokableFactory(_Icon);
export function getItemAt(factory) {
    return function (target) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        return class extends target {
            getItemAt(index) {
                return factory(this, `itemAt(index=${index})`);
            }
        };
    };
}
/**
 * Adds the getRange method to the tagged class
 */
export function getRange() {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (target) {
        return class extends target {
            getRange() {
                return Range(this, "range");
            }
        };
    };
}
//# sourceMappingURL=types.js.map